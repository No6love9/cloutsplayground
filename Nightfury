#!/usr/bin/env python3
"""
OMNIFRAME ULTIMATE - Enterprise OSINT with Psychological Profiling
Complete all-in-one solution for advanced intelligence gathering
"""

import sys
import os
import json
import logging
import asyncio
import threading
import time
import base64
import re
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Any, Optional, Set
from collections import defaultdict

# Check and install missing dependencies
try:
    import requests
    import pandas as pd
    import numpy as np
    from bs4 import BeautifulSoup
    import questionary
    from questionary import Style
    import aiodns
    import nmap
    from selenium import webdriver
    from selenium.webdriver.common.by import By
    from selenium.webdriver.support.ui import WebDriverWait
    from selenium.webdriver.support import expected_conditions as EC
    from selenium.webdriver.chrome.options import Options
    from sklearn.feature_extraction.text import TfidfVectorizer
    from sklearn.cluster import DBSCAN
    import networkx as nx
    import matplotlib.pyplot as plt
    from cryptography.fernet import Fernet
    from cryptography.hazmat.primitives import hashes
    from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
    
    # UI dependencies
    from PyQt5.QtWidgets import (QApplication, QMainWindow, QTabWidget, QWidget, QVBoxLayout, QHBoxLayout,
                                QLabel, QLineEdit, QPushButton, QTextEdit, QTreeWidget, QTreeWidgetItem,
                                QListWidget, QListWidgetItem, QProgressBar, QMessageBox, QFileDialog,
                                QSplitter, QFormLayout, QStatusBar, QToolBar, QAction, QDialog, QInputDialog)
    from PyQt5.QtCore import Qt, QThread, pyqtSignal, QTimer, QSize
    from PyQt5.QtGui import QFont, QPalette, QColor, QIcon, QPixmap
    
    DEPENDENCIES_AVAILABLE = True
except ImportError as e:
    print(f"Missing dependencies: {e}")
    DEPENDENCIES_AVAILABLE = False

# Set up logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler("omniframe_operations.log"),
        logging.StreamHandler(sys.stdout)
    ]
)
logger = logging.getLogger("OmniFrameUltimate")

# ==================== CONFIGURATION MANAGEMENT ====================
class ConfigManager:
    def __init__(self, config_dir=".omniframe_config"):
        self.config_dir = Path.home() / config_dir
        self.config_file = self.config_dir / "config.encrypted"
        self.key_file = self.config_dir / "key.encrypted"
        self.ensure_directories()
        
        self.default_config = {
            "version": "2.0.0",
            "modules": {
                "enabled": ["osint_fusion", "psychological_profiler", "visualization"],
                "osint_fusion": {"max_workers": 50, "request_timeout": 30},
                "damienz_domain": {"aggressiveness": "normal", "ports": "1-1000"},
                "aegis_osint": {"targets_dir": "targets", "wordlists_dir": "wordlists"}
            },
            "api_keys": {
                "shodan": "",
                "hunterio": "",
                "virustotal": "",
                "facebook": "",
                "twitter": ""
            },
            "ui": {
                "theme": "dark",
                "color_scheme": "blue_eclipse",
                "font_size": 12
            },
            "security": {
                "encryption_enabled": True,
                "auto_update": True,
                "secure_deletion": False
            },
            "psychological_profiles": {
                "exploitation_threshold": 0.7,
                "behavioral_patterns": ["fear_response", "curiosity", "trust_vulnerability"],
                "manipulation_techniques": ["authority", "urgency", "social_proof"]
            }
        }
        
        self.config = self.load_config()
    
    def ensure_directories(self):
        self.config_dir.mkdir(exist_ok=True, parents=True)
        (self.config_dir / "data").mkdir(exist_ok=True)
        (self.config_dir / "reports").mkdir(exist_ok=True)
        (self.config_dir / "modules").mkdir(exist_ok=True)
        (self.config_dir / "exports").mkdir(exist_ok=True)
    
    def generate_key(self):
        return Fernet.generate_key()
    
    def load_key(self):
        if self.key_file.exists():
            with open(self.key_file, 'rb') as f:
                return f.read()
        else:
            key = self.generate_key()
            with open(self.key_file, 'wb') as f:
                f.write(key)
            return key
    
    def encrypt_data(self, data: str) -> bytes:
        key = self.load_key()
        fernet = Fernet(key)
        return fernet.encrypt(data.encode())
    
    def decrypt_data(self, encrypted_data: bytes) -> str:
        key = self.load_key()
        fernet = Fernet(key)
        return fernet.decrypt(encrypted_data).decode()
    
    def load_config(self):
        if self.config_file.exists():
            try:
                with open(self.config_file, 'rb') as f:
                    encrypted_data = f.read()
                decrypted_data = self.decrypt_data(encrypted_data)
                return json.loads(decrypted_data)
            except Exception as e:
                logger.error(f"Error loading config: {e}")
                return self.default_config
        else:
            return self.default_config
    
    def save_config(self):
        try:
            config_json = json.dumps(self.config, indent=2)
            encrypted_data = self.encrypt_data(config_json)
            with open(self.config_file, 'wb') as f:
                f.write(encrypted_data)
            return True
        except Exception as e:
            logger.error(f"Error saving config: {e}")
            return False
    
    def get_api_key(self, service: str):
        return self.config['api_keys'].get(service, None)
    
    def update_api_key(self, service: str, key: str):
        self.config['api_keys'][service] = key
        self.save_config()

# ==================== PSYCHOLOGICAL PROFILER ====================
class PsychologicalProfiler:
    def __init__(self, config):
        self.config = config
        self.behavioral_patterns = self.load_behavioral_patterns()
        self.manipulation_techniques = self.load_manipulation_techniques()
    
    def load_behavioral_patterns(self):
        return {
            "fear_response": {
                "indicators": ["rapid decision making", "avoidance behavior", "heightened sensitivity"],
                "exploitation_methods": ["create urgency", "invoke loss aversion", "threat modeling"],
                "effectiveness": 0.85
            },
            "curiosity": {
                "indicators": ["information seeking", "questioning behavior", "exploratory actions"],
                "exploitation_methods": ["information gap creation", "mystery building", "progressive disclosure"],
                "effectiveness": 0.75
            },
            "trust_vulnerability": {
                "indicators": ["acceptance of authority", "low skepticism", "compliance with requests"],
                "exploitation_methods": ["authority assertion", "social proof", "likability building"],
                "effectiveness": 0.90
            },
            "social_conformity": {
                "indicators": ["group following", "opinion alignment", "normative behavior"],
                "exploitation_methods": ["social proof", "group consensus", "normative influence"],
                "effectiveness": 0.80
            }
        }
    
    def load_manipulation_techniques(self):
        return {
            "authority": {
                "description": "Using perceived authority to influence behavior",
                "implementation": "Present as expert, use credentials, authoritative language",
                "success_rate": 0.82
            },
            "urgency": {
                "description": "Creating time pressure to force quick decisions",
                "implementation": "Limited time offers, impending consequences, scarcity",
                "success_rate": 0.78
            },
            "social_proof": {
                "description": "Using others' behavior to validate actions",
                "implementation": "Testimonials, user counts, popularity indicators",
                "success_rate": 0.85
            },
            "reciprocity": {
                "description": "Creating obligation through giving",
                "implementation": "Free offers, favors, unexpected gifts",
                "success_rate": 0.88
            },
            "liking": {
                "description": "Building rapport and similarity",
                "implementation": "Compliments, shared interests, personal connection",
                "success_rate": 0.79
            }
        }
    
    def analyze_target_behavior(self, target_data: Dict) -> Dict:
        analysis = {
            "vulnerabilities": [],
            "recommended_techniques": [],
            "confidence_score": 0.0,
            "risk_assessment": "low"
        }
        
        behavioral_indicators = self.extract_behavioral_indicators(target_data)
        
        for pattern_name, pattern_data in self.behavioral_patterns.items():
            pattern_match = self.assess_pattern_match(behavioral_indicators, pattern_data['indicators'])
            if pattern_match['score'] > 0.5:
                analysis['vulnerabilities'].append({
                    "pattern": pattern_name,
                    "match_confidence": pattern_match['score'],
                    "indicators_found": pattern_match['matched_indicators']
                })
        
        for vulnerability in analysis['vulnerabilities']:
            pattern_name = vulnerability['pattern']
            if pattern_name in self.behavioral_patterns:
                techniques = self.behavioral_patterns[pattern_name]['exploitation_methods']
                for technique in techniques:
                    if technique in self.manipulation_techniques:
                        analysis['recommended_techniques'].append({
                            "technique": technique,
                            "description": self.manipulation_techniques[technique]['description'],
                            "expected_success": self.manipulation_techniques[technique]['success_rate']
                        })
        
        if analysis['vulnerabilities']:
            analysis['confidence_score'] = sum(
                vuln['match_confidence'] for vuln in analysis['vulnerabilities']
            ) / len(analysis['vulnerabilities'])
            
            if analysis['confidence_score'] > 0.8:
                analysis['risk_assessment'] = "high"
            elif analysis['confidence_score'] > 0.6:
                analysis['risk_assessment'] = "medium"
        
        return analysis
    
    def extract_behavioral_indicators(self, target_data: Dict) -> List[str]:
        indicators = []
        
        if 'social_media' in target_data:
            for platform, activity in target_data['social_media'].items():
                if 'posting_frequency' in activity:
                    if activity['posting_frequency'] > 10:
                        indicators.append("high engagement")
                    elif activity['posting_frequency'] < 2:
                        indicators.append("low engagement")
                
                if 'content_types' in activity:
                    if 'opinion' in activity['content_types']:
                        indicators.append("opinion sharing")
                    if 'personal' in activity['content_types']:
                        indicators.append("personal disclosure")
        
        if 'communication' in target_data:
            comm = target_data['communication']
            if 'response_time' in comm and comm['response_time'] < 60:
                indicators.append("rapid decision making")
            
            if 'question_count' in comm and comm['question_count'] > 5:
                indicators.append("information seeking")
        
        return indicators
    
    def assess_pattern_match(self, indicators: List[str], pattern_indicators: List[str]) -> Dict:
        matched = [ind for ind in indicators if ind in pattern_indicators]
        score = len(matched) / len(pattern_indicators) if pattern_indicators else 0
        
        return {
            "score": score,
            "matched_indicators": matched,
            "total_possible": len(pattern_indicators)
        }
    
    def generate_exploitation_plan(self, psychological_analysis: Dict) -> Dict:
        plan = {
            "phases": [],
            "expected_success_rate": 0.0,
            "timeline": {},
            "contingencies": []
        }
        
        success_rates = []
        for technique in psychological_analysis['recommended_techniques']:
            success_rates.append(technique['expected_success'])
        
        if success_rates:
            plan['expected_success_rate'] = sum(success_rates) / len(success_rates)
        
        phases = [
            {
                "name": "Rapport Building",
                "techniques": ["liking", "reciprocity"],
                "duration": "1-3 days",
                "objectives": ["Establish trust", "Create obligation"]
            },
            {
                "name": "Vulnerability Exploitation",
                "techniques": [tech['technique'] for tech in psychological_analysis['recommended_techniques']],
                "duration": "2-5 days",
                "objectives": ["Leverage psychological vulnerabilities", "Achieve primary objectives"]
            },
            {
                "name": "Consolidation",
                "techniques": ["social_proof", "authority"],
                "duration": "1-2 days",
                "objectives": ["Reinforce actions", "Secure outcomes"]
            }
        ]
        
        plan['phases'] = phases
        
        plan['contingencies'] = [
            "Fallback to alternative techniques if resistance encountered",
            "Pivot to different psychological approach if needed",
            "Emergency exit protocol if detected"
        ]
        
        return plan

# ==================== OSINT MODULES ====================
class OSINTFusionModule:
    def __init__(self, config):
        self.config = config
        self.name = "OSINT Fusion"
        self.version = "1.0.0"
    
    def gather_intelligence(self, target: str) -> Dict:
        return {
            "target": target,
            "social_media_profiles": ["twitter.com/user1", "facebook.com/user1"],
            "email_addresses": ["user@example.com"],
            "associated_domains": ["example.com", "related-site.com"],
            "behavioral_patterns": ["frequent_poster", "tech_enthusiast"]
        }

class AEGISOSINTModule:
    def __init__(self, config):
        self.config = config
        self.name = "AEGIS OSINT"
        self.version = "1.0.0"
    
    def enumerate_subdomains(self, domain: str) -> Dict:
        return {
            "domain": domain,
            "subdomains": ["www.example.com", "mail.example.com", "api.example.com"],
            "discovery_methods": ["certificate_transparency", "dns_bruteforce"]
        }

class VisualizationModule:
    def __init__(self, config):
        self.config = config
        self.name = "Visualization"
        self.version = "1.0.0"
    
    def create_network_graph(self, data: Dict) -> str:
        return "Network graph generated successfully"

# ==================== CORE FRAMEWORK ====================
class OmniFrameCore:
    def __init__(self):
        self.config = ConfigManager()
        self.modules = {}
        self.target_data = {}
        self.operation_history = []
        self.reports = {}
        
        self.setup_logging()
        self.load_modules()
    
    def setup_logging(self):
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler("omniframe_operations.log"),
                logging.StreamHandler()
            ]
        )
        self.logger = logging.getLogger("OmniFrameCore")
    
    def load_modules(self):
        enabled_modules = self.config.config['modules']['enabled']
        
        module_constructors = {
            "osint_fusion": OSINTFusionModule,
            "psychological_profiler": PsychologicalProfiler,
            "visualization": VisualizationModule
        }
        
        for module_name in enabled_modules:
            if module_name in module_constructors:
                try:
                    self.modules[module_name] = module_constructors[module_name](self.config)
                    self.logger.info(f"Successfully loaded module: {module_name}")
                except Exception as e:
                    self.logger.error(f"Failed to load module {module_name}: {e}")
    
    def add_target(self, target_identifier: str, target_data: Dict = None):
        if target_data is None:
            target_data = {
                "identifier": target_identifier,
                "added": datetime.now().isoformat(),
                "last_updated": datetime.now().isoformat(),
                "data_sources": [],
                "vulnerabilities": [],
                "psychological_profile": {},
                "exploitation_plan": {}
            }
        
        self.target_data[target_identifier] = target_data
        self.save_target_data(target_identifier)
        
        return target_identifier
    
    def gather_intelligence(self, target_identifier: str, intensity: str = "normal") -> Dict:
        if target_identifier not in self.target_data:
            self.add_target(target_identifier)
        
        results = {
            "target": target_identifier,
            "workflow_type": "comprehensive",
            "start_time": datetime.now().isoformat(),
            "modules_executed": [],
            "results": {}
        }
        
        if "osint_fusion" in self.modules:
            osint_results = self.modules["osint_fusion"].gather_intelligence(target_identifier)
            results["results"]["osint"] = osint_results
            results["modules_executed"].append("osint_fusion")
        
        if "psychological_profiler" in self.modules and "osint" in results["results"]:
            psych_analysis = self.modules["psychological_profiler"].analyze_target_behavior(
                results["results"]["osint"]
            )
            results["results"]["psychological_analysis"] = psych_analysis
            results["modules_executed"].append("psychological_profiler")
        
        results["end_time"] = datetime.now().isoformat()
        results["duration"] = 0.0
        
        self.target_data[target_identifier].update({
            "last_updated": datetime.now().isoformat(),
            "data_sources": results["modules_executed"],
            "intelligence_data": results["results"]
        })
        
        if "osint" in results["results"]:
            psych_analysis = self.modules["psychological_profiler"].analyze_target_behavior(
                results["results"]["osint"]
            )
            self.target_data[target_identifier]["psychological_profile"] = psych_analysis
            
            exploitation_plan = self.modules["psychological_profiler"].generate_exploitation_plan(psych_analysis)
            self.target_data[target_identifier]["exploitation_plan"] = exploitation_plan
        
        self.save_target_data(target_identifier)
        self.operation_history.append({
            "type": "intelligence_gathering",
            "target": target_identifier,
            "time": datetime.now().isoformat(),
            "results": "success" if results else "failed"
        })
        
        return results
    
    def generate_report(self, target_identifier: str, report_type: str = "comprehensive") -> Dict:
        if target_identifier not in self.target_data:
            return {"error": "Target not found"}
        
        target_data = self.target_data[target_identifier]
        report_id = f"report_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        
        report = {
            "id": report_id,
            "target": target_identifier,
            "generated": datetime.now().isoformat(),
            "type": report_type,
            "executive_summary": self.generate_executive_summary(target_data),
            "detailed_findings": target_data.get("intelligence_data", {}),
            "psychological_profile": target_data.get("psychological_profile", {}),
            "exploitation_plan": target_data.get("exploitation_plan", {}),
            "recommendations": self.generate_recommendations(target_data)
        }
        
        self.reports[report_id] = report
        self.save_report(report_id)
        
        return report
    
    def generate_executive_summary(self, target_data: Dict) -> Dict:
        vulnerabilities = []
        if "intelligence_data" in target_data and "vulnerability_scans" in target_data["intelligence_data"]:
            for scan in target_data["intelligence_data"]["vulnerability_scans"]:
                vulnerabilities.extend(scan.get("vulnerabilities", []))
        
        return {
            "vulnerability_count": len(vulnerabilities),
            "critical_vulnerabilities": len([v for v in vulnerabilities if v.get("severity") == "critical"]),
            "psychological_risk": target_data.get("psychological_profile", {}).get("risk_assessment", "unknown"),
            "exploitation_success_probability": target_data.get("exploitation_plan", {}).get("expected_success_rate", 0)
        }
    
    def generate_recommendations(self, target_data: Dict) -> List[str]:
        recommendations = []
        
        if "intelligence_data" in target_data and "vulnerability_scans" in target_data["intelligence_data"]:
            for scan in target_data["intelligence_data"]["vulnerability_scans"]:
                for vuln in scan.get("vulnerabilities", []):
                    recommendations.append(
                        f"Address {vuln.get('type', 'unknown')} vulnerability on {scan.get('target', 'unknown')}"
                    )
        
        psych_profile = target_data.get("psychological_profile", {})
        if psych_profile and "recommended_techniques" in psych_profile:
            for technique in psych_profile["recommended_techniques"]:
                recommendations.append(
                    f"Employ {technique.get('technique', 'unknown')} technique for psychological exploitation"
                )
        
        return recommendations
    
    def save_target_data(self, target_identifier: str):
        target_file = self.config.config_dir / "data" / f"{target_identifier}.encrypted"
        try:
            data_json = json.dumps(self.target_data[target_identifier], indent=2)
            encrypted_data = self.config.encrypt_data(data_json)
            with open(target_file, 'wb') as f:
                f.write(encrypted_data)
            return True
        except Exception as e:
            self.logger.error(f"Error saving target data: {e}")
            return False
    
    def load_target_data(self, target_identifier: str) -> bool:
        target_file = self.config.config_dir / "data" / f"{target_identifier}.encrypted"
        if target_file.exists():
            try:
                with open(target_file, 'rb') as f:
                    encrypted_data = f.read()
                decrypted_data = self.config.decrypt_data(encrypted_data)
                self.target_data[target_identifier] = json.loads(decrypted_data)
                return True
            except Exception as e:
                self.logger.error(f"Error loading target data: {e}")
                return False
        return False
    
    def save_report(self, report_id: str):
        report_file = self.config.config_dir / "reports" / f"{report_id}.encrypted"
        try:
            report_json = json.dumps(self.reports[report_id], indent=2)
            encrypted_data = self.config.encrypt_data(report_json)
            with open(report_file, 'wb') as f:
                f.write(encrypted_data)
            return True
        except Exception as e:
            self.logger.error(f"Error saving report: {e}")
            return False

# ==================== ADVANCED UI ====================
class ModernButton(QPushButton):
    def __init__(self, text, parent=None):
        super().__init__(text, parent)
        self.setCursor(Qt.PointingHandCursor)
        self.setMinimumHeight(35)
        self.setStyleSheet("""
            QPushButton {
                background-color: #5a9cff;
                color: white;
                border: none;
                border-radius: 5px;
                padding: 8px 16px;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #3d8eff;
            }
            QPushButton:pressed {
                background-color: #2a7ae9;
            }
            QPushButton:disabled {
                background-color: #cccccc;
                color: #666666;
            }
        """)

class OSINTMainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Enterprise OSINT Framework")
        self.setGeometry(100, 100, 1400, 900)
        
        self.framework = OmniFrameCore()
        
        self.setup_ui()
        self.apply_dark_theme()
        
    def setup_ui(self):
        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        main_layout = QHBoxLayout(central_widget)
        
        sidebar = self.create_sidebar()
        main_layout.addWidget(sidebar)
        
        self.tabs = QTabWidget()
        self.tabs.setTabPosition(QTabWidget.North)
        self.tabs.setDocumentMode(True)
        main_layout.addWidget(self.tabs)
        
        self.setup_dashboard_tab()
        self.setup_osint_tab()
        self.setup_visualization_tab()
        self.setup_reporting_tab()
        
        self.status_bar = QStatusBar()
        self.setStatusBar(self.status_bar)
        self.status_bar.showMessage("Ready")
        
        self.setup_toolbar()
    
    def create_sidebar(self):
        sidebar = QWidget()
        sidebar.setFixedWidth(300)
        sidebar_layout = QVBoxLayout(sidebar)
        
        search_box = QLineEdit()
        search_box.setPlaceholderText("Search targets...")
        sidebar_layout.addWidget(search_box)
        
        targets_list = QListWidget()
        sidebar_layout.addWidget(targets_list)
        
        quick_actions = QWidget()
        quick_actions_layout = QVBoxLayout(quick_actions)
        quick_actions_layout.addWidget(ModernButton("New Target"))
        quick_actions_layout.addWidget(ModernButton("Quick Scan"))
        quick_actions_layout.addWidget(ModernButton("Generate Report"))
        
        sidebar_layout.addWidget(quick_actions)
        sidebar_layout.addStretch()
        
        return sidebar
    
    def setup_dashboard_tab(self):
        dashboard_tab = QWidget()
        layout = QVBoxLayout(dashboard_tab)
        
        welcome_label = QLabel("Enterprise OSINT Framework Dashboard")
        welcome_label.setStyleSheet("font-size: 24px; font-weight: bold; color: #00f3ff;")
        layout.addWidget(welcome_label)
        
        stats_widget = self.create_stats_widget()
        layout.addWidget(stats_widget)
        
        recent_activity = QTextEdit()
        recent_activity.setPlaceholderText("Recent activity will appear here...")
        layout.addWidget(recent_activity)
        
        self.tabs.addTab(dashboard_tab, "Dashboard")
    
    def create_stats_widget(self):
        stats_widget = QWidget()
        stats_layout = QHBoxLayout(stats_widget)
        
        stats = [
            {"title": "Targets", "value": "15", "change": "+3"},
            {"title": "Reports", "value": "27", "change": "+8"},
            {"title": "Findings", "value": "134", "change": "+24"},
            {"title": "Vulnerabilities", "value": "42", "change": "+7"}
        ]
        
        for stat in stats:
            stat_frame = QWidget()
            stat_frame.setStyleSheet("background-color: #1e1e2f; border-radius: 10px; padding: 10px;")
            stat_layout = QVBoxLayout(stat_frame)
            
            title = QLabel(stat["title"])
            value = QLabel(stat["value"])
            value.setStyleSheet("font-size: 24px; font-weight: bold; color: #00f3ff;")
            change = QLabel(stat["change"])
            change.setStyleSheet("color: #00ff9d;")
            
            stat_layout.addWidget(title)
            stat_layout.addWidget(value)
            stat_layout.addWidget(change)
            
            stats_layout.addWidget(stat_frame)
        
        return stats_widget
    
    def setup_osint_tab(self):
        osint_tab = QWidget()
        layout = QVBoxLayout(osint_tab)
        
        tools_widget = self.create_osint_tools_widget()
        layout.addWidget(tools_widget)
        
        results_display = QTextEdit()
        results_display.setPlaceholderText("OSINT results will appear here...")
        layout.addWidget(results_display)
        
        self.tabs.addTab(osint_tab, "OSINT Tools")
    
    def create_osint_tools_widget(self):
        tools_widget = QWidget()
        tools_layout = QHBoxLayout(tools_widget)
        
        tools = [
            ("Subdomain Enumeration", self.run_subdomain_enum),
            ("Port Scanning", self.run_port_scan),
            ("Social Media Analysis", self.run_social_analysis),
            ("Data Correlation", self.run_data_correlation)
        ]
        
        for tool_name, tool_func in tools:
            btn = ModernButton(tool_name)
            btn.clicked.connect(tool_func)
            tools_layout.addWidget(btn)
        
        return tools_widget
    
    def setup_visualization_tab(self):
        visualization_tab = QWidget()
        layout = QVBoxLayout(visualization_tab)
        
        visualization_label = QLabel("Data Visualization")
        visualization_label.setStyleSheet("font-size: 18px; font-weight: bold;")
        layout.addWidget(visualization_label)
        
        visualization_placeholder = QLabel("Network graphs and data visualizations will appear here")
        visualization_placeholder.setAlignment(Qt.AlignCenter)
        layout.addWidget(visualization_placeholder)
        
        self.tabs.addTab(visualization_tab, "Visualization")
    
    def setup_reporting_tab(self):
        reporting_tab = QWidget()
        layout = QVBoxLayout(reporting_tab)
        
        reporting_label = QLabel("Report Generation")
        reporting_label.setStyleSheet("font-size: 18px; font-weight: bold;")
        layout.addWidget(reporting_label)
        
        report_controls = QWidget()
        report_controls_layout = QHBoxLayout(report_controls)
        
        report_types = ["Comprehensive", "Executive Summary", "Technical Deep Dive"]
        for report_type in report_types:
            btn = ModernButton(f"Generate {report_type} Report")
            report_controls_layout.addWidget(btn)
        
        layout.addWidget(report_controls)
        
        report_preview = QTextEdit()
        report_preview.setPlaceholderText("Report preview will appear here...")
        layout.addWidget(report_preview)
        
        self.tabs.addTab(reporting_tab, "Reporting")
    
    def setup_toolbar(self):
        toolbar = QToolBar("Main Toolbar")
        toolbar.setIconSize(QSize(24, 24))
        self.addToolBar(toolbar)
        
        actions = [
            ("New Target", "document-new", self.new_target),
            ("Import Data", "document-open", self.import_data),
            ("Export Report", "document-save", self.export_report),
            ("Settings", "preferences-system", self.open_settings)
        ]
        
        for action_text, icon_name, callback in actions:
            action = QAction(QIcon.fromTheme(icon_name), action_text, self)
            action.triggered.connect(callback)
            toolbar.addAction(action)
    
    def apply_dark_theme(self):
        dark_palette = QPalette()
        dark_palette.setColor(QPalette.Window, QColor(53, 53, 53))
        dark_palette.setColor(QPalette.WindowText, Qt.white)
        dark_palette.setColor(QPalette.Base, QColor(25, 25, 25))
        dark_palette.setColor(QPalette.AlternateBase, QColor(53, 53, 53))
        dark_palette.setColor(QPalette.ToolTipBase, Qt.white)
        dark_palette.setColor(QPalette.ToolTipText, Qt.white)
        dark_palette.setColor(QPalette.Text, Qt.white)
        dark_palette.setColor(QPalette.Button, QColor(53, 53, 53))
        dark_palette.setColor(QPalette.ButtonText, Qt.white)
        dark_palette.setColor(QPalette.BrightText, Qt.red)
        dark_palette.setColor(QPalette.Link, QColor(42, 130, 218))
        dark_palette.setColor(QPalette.Highlight, QColor(42, 130, 218))
        dark_palette.setColor(QPalette.HighlightedText, Qt.black)
        
        self.setPalette(dark_palette)
        
        self.setStyleSheet("""
            QMainWindow, QWidget {
                background-color: #1e1e2f;
                color: #f0f8ff;
            }
            QTabWidget::pane {
                border: 1px solid #4a4a4a;
                background: #282c34;
            }
            QTabBar::tab {
                background: #282c34;
                color: #abb2bf;
                padding: 10px;
                border: 1px solid #4a4a4a;
                border-bottom: none;
                border-top-left-radius: 5px;
                border-top-right-radius: 5px;
            }
            QTabBar::tab:selected {
                background: #3d8eff;
                color: white;
            }
            QStatusBar {
                background: #21252b;
                color: #abb2bf;
            }
        """)
    
    def new_target(self): 
        target, ok = QInputDialog.getText(self, "New Target", "Enter target name:")
        if ok and target:
            self.framework.add_target(target)
            self.status_bar.showMessage(f"Added target: {target}")
    
    def import_data(self): 
        QMessageBox.information(self, "Import", "Data import functionality")
    
    def export_report(self): 
        QMessageBox.information(self, "Export", "Report export functionality")
    
    def open_settings(self): 
        QMessageBox.information(self, "Settings", "Settings configuration")
    
    def run_subdomain_enum(self): 
        self.status_bar.showMessage("Running subdomain enumeration...")
    
    def run_port_scan(self): 
        self.status_bar.showMessage("Running port scan...")
    
    def run_social_analysis(self): 
        self.status_bar.showMessage("Running social media analysis...")
    
    def run_data_correlation(self): 
        self.status_bar.showMessage("Running data correlation...")

# ==================== MAIN APPLICATION ====================
def main():
    if not DEPENDENCIES_AVAILABLE:
        print("Error: Required dependencies are not installed.")
        print("Please install: pip install requests pandas beautifulsoup4 questionary aiodns python-nmap selenium scikit-learn networkx matplotlib cryptography PyQt5")
        return
    
    app = QApplication(sys.argv)
    
    # Apply modern style if available
    try:
        import qtmodern.styles
        qtmodern.styles.dark(app)
    except ImportError:
        print("qtmodern not available, using default style")
    
    window = OSINTMainWindow()
    
    # Apply modern window styling if available
    try:
        import qtmodern.windows
        modern_window = qtmodern.windows.ModernWindow(window)
        modern_window.show()
    except:
        window.show()
    
    sys.exit(app.exec_())

if __name__ == "__main__":
    # Quick test if run directly
    if len(sys.argv) > 1 and sys.argv[1] == "test":
        print("ðŸ§ª Testing OmniFrame Ultimate...")
        framework = OmniFrameCore()
        framework.add_target("example.com")
        results = framework.gather_intelligence("example.com")
        print(f"âœ… Framework test successful!")
        print(f"ðŸ“Š Psychological risk: {results['results'].get('psychological_analysis', {}).get('risk_assessment', 'unknown')}")
    else:
        main()
